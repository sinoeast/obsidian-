# mysql
## 1.行转列 列转行
![image.png](https://gitee.com/sinoeast/imgs/raw/master/20230523134235.png)

```sql
SELECT userid,
SUM(CASE `subject` WHEN '语文' THEN score ELSE 0 END) as '语文',
SUM(CASE `subject` WHEN '数学' THEN score ELSE 0 END) as '数学',
SUM(CASE `subject` WHEN '英语' THEN score ELSE 0 END) as '英语',
SUM(CASE `subject` WHEN '政治' THEN score ELSE 0 END) as '政治' 
FROM tb_score 
GROUP BY userid
```

```sql
SELECT userid,
SUM(IF(`subject`='语文',score,0)) as '语文',
SUM(IF(`subject`='数学',score,0)) as '数学',
SUM(IF(`subject`='英语',score,0)) as '英语',
SUM(IF(`subject`='政治',score,0)) as '政治' 
FROM tb_score 
GROUP BY userid
```
注意点：

（1）SUM() 是为了能够使用GROUP BY根据userid进行分组，因为每一个userid对应的subject="语文"的记录只有一条，所以SUM() 的值就等于对应那一条记录的score的值。

假如userid =‘001’ and subject=‘语文’ 的记录有两条，则此时SUM() 的值将会是这两条记录的和，同理，使用Max()的值将会是这两条记录里面值最大的一个。但是正常情况下，一个user对应一个subject只有一个分数，因此可以使用SUM()、MAX()、MIN()、AVG()等聚合函数都可以达到行转列的效果。

（2）IF(`subject`=‘语文’,score,0) 作为条件，即对所有subject='语文’的记录的score字段进行SUM()、MAX()、MIN()、AVG()操作，如果score没有值则默认为0。

```sql
SELECT IFNULL(userid,'TOTAL') AS userid,
SUM(IF(`subject`='语文',score,0)) AS 语文,
SUM(IF(`subject`='数学',score,0)) AS 数学,
SUM(IF(`subject`='英语',score,0)) AS 英语,
SUM(IF(`subject`='政治',score,0)) AS 政治,
SUM(score) AS TOTAL 
FROM tb_score
GROUP BY userid WITH ROLLUP;
```
行转列
![image.png](https://gitee.com/sinoeast/imgs/raw/master/20230523134759.png)

```sql
SELECT userid,'语文' AS course,cn_score AS score FROM tb_score1
UNION ALL
SELECT userid,'数学' AS course,math_score AS score FROM tb_score1
UNION ALL
SELECT userid,'英语' AS course,en_score AS score FROM tb_score1
UNION ALL
SELECT userid,'政治' AS course,po_score AS score FROM tb_score1
ORDER BY userid
```
## 2.索引的设计怎么是合理的
1.最适合索引的列是出现在 where子句中的列，或连接子句中指定的列，也就是过滤条件所在的列
2.索引的列的基数越大，分布越松散，索引的效果越好
3.如果对字符串列进行索引，应该指定一个前缀长度，只要有可能就应该这样做例如，如果有一个 char(200)列，如果在前 10 个或 20 个字符内，多数值是惟一的，那么就不要对整个列进行索引。对前10个或20个字符进行索引能够节省大量索引空间，也可能会使查询更快
4.
# 介绍
1.重要的功能 背景 使用客户 怎么做测试设计 列举一个功能
之前做的集团风险产品主要用于证券公司风控部门，用于他们方便查看一些业务数据监控风控指标的，我们主要从一些上游获取 客户类型的数据，业务类型的数据和资讯类型的数据，然后在我们的软件把这些数据进行串联打通，比如从业务角度看到该业务涉及到的客户信息和舆情信息，在客户角度可以看到该客户涉及到的一些业务信息，舆情风险等等。
主要交互就是展示对应数据信息，所以测试设计的重点就是取数的逻辑是否正确，一般测试分析时是主要考虑表之间的关联关系是一对一还是一对多，多对多这种，还有各个字段的取值逻辑，需要计算的和直接可以取值的，在分析评审的时间和产品开发确定好。
比如a股的业务明细，需要的业务数据从证券持仓表中取来，其中的客户信息需要持仓表关联发行人表一对一关联获取发行人的一些信息。首先是关联方式因为要保证业务明细数据不缺失要用左关联保留持仓表的数据，其次是关联条件要确保一对一关联，然后是一些前端传的where条件，最后就是字段的取值按照评审时的设计（如果有一些除数被除数为0的处理，字典值的处理）

2.测试时间比较紧张怎么保障和协调
1.首先评估是否有延期的风险及时汇报领导，需要多少人手协助
2.如果没有人手就要制定计划按照优先级排序完成优先级高的任务，优先级低的放到下个版本，将计划交给领导审核

3.线上bug
1、评估bug的严重程度和产生原因。  
2、确定不同的解决方案，回滚到稳定版本或采取其他措施。  
3、复现bug。记录bug重现步骤,协助开发快速定位问题。  
4、bug解决后测试环境回归。确定整体功能ok，不能引入新bug.  
5、重新发到线上后留意用户反馈,看是否还有该问题。  
6、复盘。分析整个过程，思考问题和改善方案，避免类似问题重复出现。  
出现线上bug常见的原因：  
1.流程不规范，比如上线的代码里边包含了正在开发且未提测的内容  
2.代码review不到位  
3.没有对修复代码的影响范围进行评估，  
4.漏测，等等。


# java
1.  确定文件的搜索入口
    
2.  确定递归出口，当搜索的文件是null，那就直接返回，退出递归搜索
    
3.  如果当前是一个文件夹，那就依次搜索该文件夹中的子文件夹
    
4.  如果当前是一个文件，搜索完成，现在可以对该文件进行相应的处理
查询文件
```java
public class FileTest {
    public static void main(String[] args) {
        File file = new File("D:\\Android Project");
        searchFile(file);
    }
 
    private static void searchFile(File file){
        // 递归出口
        if(file == null) {
            return;
        }
        if(file.isDirectory()) {
            // 如果是一个文件夹，那就递归搜索该文件夹中的所有子文件。
            File[] files = file.listFiles(); // 返回子文件夹
            for(File file1: files) {
                searchFile(file1);
            }
        }
        else {
            // 如果是一个文件，搜索就完成了。
            System.out.println(file.getAbsolutePath());
        }
    }
}
```
