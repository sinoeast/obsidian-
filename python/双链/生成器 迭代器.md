### 1. 生成器的介绍

根据程序员制定的规则循环生成数据，当条件不成立时则生成数据结束。数据不是一次性全部生成出来，而是使用一个，再生成一个，可以**节约大量的内存**。

### 2. 创建生成器的方式

1.  生成器推导式
2.  yield 关键字

**生成器推导式:**

-   与列表推导式类似，只不过生成器推导式使用小括号
[[4.其他查询#列表推导式]]
```python
# 创建生成器
my_generator = (i * 2 for i in range(5))
print(my_generator)

# next获取生成器下一个值
# value = next(my_generator)
# print(value)

# 遍历生成器
for value in my_generator:
    print(value)
```

**代码说明:**

-   next 函数获取生成器中的下一个值
-   for 循环遍历生成器中的每一个值

**运行结果:**

```
<generator object <genexpr> at 0x101367048>
0
2
4
6
8
```

**yield 关键字:**

-   只要在def函数里面看到有 yield 关键字那么就是生成器

```python
def mygenerater(n):
    for i in range(n):
        print('开始生成...')
        yield i
        print('完成一次...')


if __name__ == '__main__':

    g = mygenerater(2)
    # 获取生成器中下一个值
    # result = next(g)
    # print(result)

    # while True:
    #     try:
    #         result = next(g)
    #         print(result)
    #     except StopIteration as e:
    #         break

    # # for遍历生成器, for 循环内部自动处理了停止迭代异常，使用起来更加方便
    for i in g:
        print(i)
```

**代码说明:**

-   代码执行到 yield 会暂停，然后把结果返回出去，下次启动生成器会在暂停的位置继续往下执行
-   生成器如果把数据生成完成，再次获取生成器中的下一个数据会抛出一个StopIteration 异常，表示停止迭代异常
-   while 循环内部没有处理异常操作，需要手动添加处理异常操作
-   for 循环内部自动处理了停止迭代异常，使用起来更加方便，推荐大家使用。

**运行结果:**

```
开始生成...
0
完成一次...
开始生成...
1
完成一次...
```

### 3. 生成器的使用场景

数学中有个著名的斐波拉契数列（Fibonacci），数列中第一个数为0，第二个数为1，其后的每一个数都可由前两个数相加得到：

0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...

现在我们使用生成器来实现这个斐波那契数列，每次取值都通过算法来生成下一个数据, **生成器每次调用只生成一个数据，可以节省大量的内存。**

```python
def fibonacci(num):
    a = 0
    b = 1

    # 记录生成fibonacci数字的下标
    current_index = 0

    while current_index < num:
        result = a
        a, b = b, a + b
        current_index += 1
        # 代码执行到yield会暂停，然后把结果返回出去，下次启动生成器会在暂停的位置继续往下执行
        yield result


fib = fibonacci(5)
# 遍历生成的数据
for value in fib:
    print(value)
```

**运行结果:**

```
0
1
1
2
3
```

### 4. 小结

-   生成器是根据算法生成数据的一种机制，每次调用生成器只生成一个值，可以节省大量内存。
-   生成器的创建有两种方式:
    -   1.  生成器推导式
    -   1.  yield 关键字

# 迭代器和生成器
*一句话理解*
*从数据集中一次按需获取一个数据项*，这就是迭代器，迭代器强调是从数据集一次获取一个数据项，而生成器指*“凭空”生成元素*，然后也是可以一个一个获取；
生成器中包含了迭代器的抽象（或者说接口、结构、方法），所以，所有的生成器都是迭代器。很多人视为同一概念

简单来说：生成器是创建迭代器的快捷工具。
生成器特点：利用yield返回数据，自动创建__iter__()和__next__()方法，写法更为紧凑和清晰。

专业的理解（装B的表达）：生成器是创建迭代器代码的抽象

## 迭代器
Python中一个实现_iter_方法和_next_方法的类对象，就是迭代器。
是一个能记住遍历位置的对象，遍历时只能往前，不能后退。迭代器常用方法有 iter() 和 next().
把一个类作为迭代器使用需要在类中实现两个函数：__iter__() 和 __next__().

## 生成器

Python 中使用了 yield 的函数称为生成器，生成器函数返回一个迭代器。
在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。
生成器函数自动实现了迭代器协议，能更方便地实现。
生成器函数 和 生成器表达式都可以提供生成器，只需要简单地将列表推导的中括号替换成圆括号即可

## 二者区别

1.*迭代器是访问容器的一种方式，也就是说容器已经出现。我们是从已有元素拓印出一份副本，只为我们此次迭代使用。而生成器则是，而生成器则是自己生成元素的。*
2.在用法上生成器只需要简单函数写法，配合yield就能实现。而迭代器真正开发中很难使用到。我们可以把生成器看做，python给我们提供的特殊接口实现的迭代器。
3.生成器是只能遍历一次的。

## 为什么使用生成器

Python使用生成器对延迟操作提供了支持。在需要的时候才产生结果，而不是立即产生结果。
1、节省资源消耗，和声明序列不同的是生成器在不使用的时候几乎不占内存，也没有声明计算过程！
2、使用的时候，生成器是随用随生成，用完即刻释放，非常高效！
3、可在单线程下实现并发运算处理效果。

## yeild 与 return的区别

相同点：都是返回函数执行的结果
不同点：return 在返回结果后结束函数的运行，而yield 则是让函数变成一个生成器，生成器每次产生一个值（yield语句），函数被冻结，被唤醒后再产生一个值